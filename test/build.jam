# Copyright Rene Rivera 2011-2023
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE_1_0.txt or copy at
# http://www.boost.org/LICENSE_1_0.txt)

import-search ../tools/check ;
import predef : require check : predef-require predef-check ;
import common ;
import path ;
import regex ;

project
    :   requirements
        # Add explicit dependency since we don't have header scanner for
        # .m and .mm files.
        <dependency>../include/predef.h
    ;

using testing ;

alias predef-info-c :
    [ run info_as_c.c : : : <test-info>always_show_run_output ]
    ;

alias predef-info-cpp :
    [ run info_as_cpp.cpp : : : <test-info>always_show_run_output ]
    ;

alias predef-info-objc :
    [ run info_as_objcpp.mm : : : <test-info>always_show_run_output ]
    [ run info_as_objc.m : : : <test-info>always_show_run_output ]
    : <conditional>@objc
    ;

alias predef-info : predef-info-c predef-info-cpp predef-info-objc ;

rule objc ( props * )
{
    if ! ( <target-os>darwin in $(props) )
    {
        return <build>no ;
    }
}

alias predef :
    [ run version.cpp ]
    [ run make.cpp ]
    [ compile macos_endian.c : [ predef-require "HASH_PREDEF_OS_MACOS" : cpp ] ]
    [ compile macos_vs_bsd.c : [ predef-require "HASH_PREDEF_OS_MACOS" : cpp ] ]
    [ run check_value.cpp : : : <test-info>always_show_run_output
        [ predef-check "HASH_PREDEF_COMP_CLANG > 0.0.0" "HASH_PREDEF_OS_LINUX == 0" : : <cxxflags>-DCHECK_VALUE=true ] ]
    [ run workaround.cpp ]
    [ compile workaround_strict_config.cpp ]
    [ run tested_at.cpp ]
    [ compile-fail tested_at_outdated.cpp : <test-info>always_show_run_output ]
    [ compile platform_windows.cpp ]
    ;

local single_header_c ;
for local h in [ glob-tree-ex ../include/predef : *.h ]
{
    local header_include = [ path.relative $(h) ../include ] ;
    local header_src = [ regex.replace $(header_include:S=)_c.c "/" "_" ] ;
    local header_target = $(header_src:B:S=) ;
    .HEADER($(header_target)) = $(header_include) ;
    make $(header_src) : : @gen_single_header_c_or_cpp ;
    explicit $(header_src) ;
    compile $(header_src) : <warnings-as-errors>on <warnings>all : $(header_target) ;
    explicit $(header_target) ;
    single_header_c += $(header_target) ;
}

local single_header_cpp ;
for local h in [ glob-tree-ex ../include/predef : *.h ]
{
    local header_include = [ path.relative $(h) ../include ] ;
    local header_src = [ regex.replace $(header_include:S=)_cpp.cpp "/" "_" ] ;
    local header_target = $(header_src:B:S=) ;
    .HEADER($(header_target)) = $(header_include) ;
    make $(header_src) : : @gen_single_header_c_or_cpp ;
    explicit $(header_src) ;
    compile $(header_src) : <warnings-as-errors>on <warnings>all : $(header_target) ;
    explicit $(header_target) ;
    single_header_cpp += $(header_target) ;
}

alias predef-headers-c : $(single_header_c) ;
alias predef-headers-cpp : $(single_header_cpp) ;
alias predef-headers : predef-headers-c predef-headers-cpp ;

.file_touch_cmd = [ common.file-touch-command ] ;

rule gen_single_header_c_or_cpp ( target * : source * : properties * )
{
    HEADER on $(target) = $(.HEADER($(target[1]:B))) ;
}
actions gen_single_header_c_or_cpp
{
    $(.file_touch_cmd) @($(<):<=":>=":O=F:E=#include <$(HEADER)>)
}

# Minimal testing done for predef for CI. Since
# we don't have many we can just do all of them.
alias minimal : predef predef-info ;

# Full testing target for regular regression tests.
alias full : predef predef-info ;

# Extra's target.
alias extra : predef-headers ;

# Language specific tests only.
alias c : predef-info-c predef-headers-c ;
alias cpp : predef-info-cpp predef-headers-cpp ;

alias all : predef predef-info predef-headers ;

explicit minimal ;
explicit extra ;
explicit all ;
explicit c ;
explicit cpp ;
